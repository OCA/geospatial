# Copyright (C) 2020 Brian McMaster
# License AGPL-3.0 or later (http://www.gnu.org/licenses/agpl).

import logging
import json
import urllib

from ortools.constraint_solver import routing_enums_pb2
from ortools.constraint_solver import pywrapcp

from odoo import _, api, models
from odoo.exceptions import ValidationError

_logger = logging.getLogger(__name__)


class GeoRouteOptimize(models.AbstractModel):
    """ This model is meant to solve the Traveling Salesman Problem
       and/or the Vehicle Routing Problem.
       It is meant to be inherited by any model that needs to efficiently
       optimize the sequence in which records are ordered, specifically for
       driving purposes.
       Distances between records are calculated and stored in a matrix that is
       generated by the Google Distance Matrix API
       The optimization problem is solved using Google OR Tools python package
       The functions in this model are based on the examples provided in the
       following link.
       More information at https://developers.google.com/optimization/routing
    """

    _name = "geo.route.optimize"
    _description = "Geo Route Optimization Framework"

    def send_request(self, origin_addresses, dest_addresses):
        """ Build and send the API request for the given origin and
           destination addresses.
        """
        ICPSudo = self.env["ir.config_parameter"].sudo()
        api_key = ICPSudo.get_param("google.api_key_distance_matrix")
        if not api_key:
            raise ValidationError(_("No Google Distance Matrix API key defined"))
        request = (
            "https://maps.googleapis.com/maps/api/distancematrix/json?units=imperial"
        )
        origin_address_str = "|".join(origin_addresses)
        dest_address_str = "|".join(dest_addresses)
        request = (
            request
            + "&origins="
            + origin_address_str
            + "&destinations="
            + dest_address_str
            + "&key="
            + api_key
        )
        try:
            jsonResult = urllib.request.urlopen(request).read()
            response = json.loads(jsonResult)
        except urllib.error.URLError as e:
            raise ValidationError(
                _("Failure when making Distance Matrix API request: %s", e)
            )
        return response

    def build_distance_matrix(self, response):
        """The following function builds rows of the distance matrix,
           using the response returned by the send_request function."""
        distance_matrix = []
        for row in response["rows"]:
            row_list = []
            for j in range(len(row["elements"])):
                row_list.append(row["elements"][j]["duration"]["value"])
            distance_matrix.append(row_list)
        return distance_matrix

    def create_distance_matrix(self, addresses):
        """ Create the entire distance matrix. The Distance Matrix API only
           accepts 100 elements per request, multiple requests may be needed
        """
        max_elements = 100
        num_addresses = len(addresses)
        # Maximum number of rows that can be computed per request
        max_rows = max_elements // num_addresses
        # num_addresses = q * max_rows + r
        q, r = divmod(num_addresses, max_rows)
        dest_addresses = addresses
        distance_matrix = []
        # Send q requests, returning max_rows rows per request.
        for i in range(q):
            origin_addresses = addresses[i * max_rows : (i + 1) * max_rows]
            response = self.send_request(origin_addresses, dest_addresses)
            distance_matrix += self.build_distance_matrix(response)
        # Get the remaining remaining r rows, if necessary.
        if r > 0:
            origin_addresses = addresses[q * max_rows : q * max_rows + r]
            response = self.send_request(origin_addresses, dest_addresses)
            distance_matrix += self.build_distance_matrix(response)
        return distance_matrix

    def prepare_destinations(self):
        """ Inherit this function in your model to provide the location
            parameters for the Google Directions API request
            https://developers.google.com/maps/documentation/directions/intro#RequestParameters
            :return list: a list of strings representing the destination
             address for each record in the recordset
        """
        destinations = []
        return destinations

    def get_route(self, manager, routing, solution):
        """ Get route and durations between route nodes from a solution.
           Return a dictionary of the lists generated."""
        index = routing.Start(0)
        vehicle_id = 0
        route = [manager.IndexToNode(index)]
        trip_durations = []
        while not routing.IsEnd(index):
            previous_index = index
            index = solution.Value(routing.NextVar(index))
            # Build sorted route node list
            route.append(manager.IndexToNode(index))
            # Create list of durations between route nodes
            trip_durations.append(
                routing.GetArcCostForVehicle(previous_index, index, vehicle_id)
            )
        return {
            "route": route,
            "durations": trip_durations,
        }

    @api.multi
    def optimize_records(self, origin):
        """ This is the primary function to initiate the geo optimization of a
           recordset. You must provide an origin string parameter in the same
           format as required in the prepare_destinations function.
           Returns a dictionary with a list of the record ids sorted in
           the optimized order and a list of durations between nodes
        """
        if not origin:
            raise ValidationError(_("No origin defined for route optimization"))
        unsorted_ids = self.ids
        num_vehicles = 1
        # A depot (start & end point) is the first index in `[addresses]`
        DEPOT = 0
        destinations = self.prepare_destinations()
        addresses = [origin] + destinations
        distance_matrix = self.create_distance_matrix(addresses)
        _logger.info("Distance Matrix: %s", distance_matrix)
        # Create the routing index manager.
        manager = pywrapcp.RoutingIndexManager(
            len(distance_matrix), num_vehicles, DEPOT
        )
        # Create Routing Model.
        routing = pywrapcp.RoutingModel(manager)
        # Create and register a transit callback.

        def distance_callback(from_index, to_index):
            # Returns the distance between the two nodes
            # Convert from routing variable Index to distance matrix NodeIndex.
            from_node = manager.IndexToNode(from_index)
            to_node = manager.IndexToNode(to_index)
            return distance_matrix[from_node][to_node]

        transit_callback_index = routing.RegisterTransitCallback(distance_callback)
        # Define cost of each arc.
        routing.SetArcCostEvaluatorOfAllVehicles(transit_callback_index)
        # Setting first solution heuristic.
        search_parameters = pywrapcp.DefaultRoutingSearchParameters()
        search_parameters.first_solution_strategy = (
            routing_enums_pb2.FirstSolutionStrategy.PATH_CHEAPEST_ARC
        )
        # Solve the problem.
        solution = routing.SolveWithParameters(search_parameters)
        sorted_ids = []
        durations = []
        # Use soloution to get the ids of records in order of route sequence
        if solution:
            route_dict = self.get_route(manager, routing, solution)
            # Use the route nodes to make a list of sorted record ids
            route = route_dict["route"]
            for dest in route:
                # depot location does not get added to the list of ids
                if route[dest] != DEPOT:
                    sorted_ids.append(unsorted_ids[dest - 1])
            _logger.info("Sorted IDs: %s", sorted_ids)
            durations = route_dict["durations"]
        return {
            "sorted_ids": sorted_ids,
            "durations": durations,
        }
